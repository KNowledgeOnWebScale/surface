<pre class='metadata'>
Title: RDF Surfaces Primer
Level: 1
Status: LD
Editor: Jos De Roo, [KNoWS](https://knows.idlab.ugent.be/team/), jos.deroo@ugent.be 
Editor: Patrick Hochstenbach, [KNoWS](https://knows.idlab.ugent.be/team/), patrick.hochstenbach@ugent.be 
Abstract: This document specifies a Notation3 sublanguage to express RDF Surfaces.
Markup Shorthands: markdown yes 
Boilerplate: 
</pre>

<style>
table {
  margin: 25px auto;
  border-collapse: collapse;
  border: 1px solid #eee;
  border-bottom: 2px solid #005A9C;
}
table tr:hover {
  background: #f4f4f4;
}
table tr:hover td {
  color: #555;
}
table th, table td {
  color: #999;
  border: 1px solid #eee;
  padding: 12px 12px;
  border-collapse: collapse;
}
table th {
  background: #005A9C;
  color: #fff;
}
table tbody > tr > th {
  background: #fff;
  color: #005A9C;
}
table th.last {
  border-right: none;
}
</style>

Introduction {#Introduction}
=====================

Based on:
[BLOGIC](https://www.slideshare.net/PatHayes/blogic-iswc-2009-invited-talk) 

An RDF surface is a kind of a sheet of paper on which RDF graphs can be written.
All triples that are part of an RDF graph are then on this sheet of paper, including all
[[URI]]s, literals and [Blank nodes](https://www.w3.org/TR/rdf11-mt/#blank-nodes). 
A sheet of paper can contain more than one RDF graph. An RDF graph can't be split
over multiple sheets of paper. But, one can copy an RDF graph from one sheet of 
paper to another sheet of paper.

[Blank nodes](https://www.w3.org/TR/rdf11-mt/#blank-nodes) are special. They can't 
be copied to a new piece of paper. They can be thought of scratches on a piece of 
paper. These scratches, or graffiti, are engraved into the piece of paper and can't
be transferred. When copying data with blank nodes onto a new sheet of paper, 
new scratches need to be made.

<div class=example>
An empty *positive surface* is a tautology.

<img alt="blank surface" src="images/positive_surface.svg" width="300"/>
</div>

<div class=example>
A *positive surface* with one triple `:Gent a :City`, which means *"Ghent is a city"*.

<img alt="blank surface" src="images/one_assertion.svg" width="300"/>
</div>

<div class=example>
A *positive surface* with one triple containing a blank node `[] a :City`, which means *"There is something that is a city"*. 

<img alt="blank surface" src="images/blank_node.svg" width="300"/>
</div>

<div class=example>
Two *positive surfaces*, one with the triple `[] a :City` (which means *"There is something that is a city"*),
and another one with the triple `[] a :Cat` (which means *"There is something is a cat"*). 

<img alt="blank surface" src="images/two_sheets.svg" width="600"/>

One can copy these two RDFs graphs to a new surface. This will contain two graphs with 
two blank nodes:

```
[] a :City .
[] a :Cat .
```

This means, "There is something that is a city AND There is something that is a cat."

<img alt="blank surface" src="images/city_cat.svg" width="300"/>
</div>

**Positive surface**

There are special sheets of paper that can be interpreted as a logical statement.
For instance, the sheet of paper in Example 1 is an example of a **positive surface**
(we use in this document a paper with a black border as a positive surface). Any
RDF graph written on this surface is interpreted as logical assertion (true). An empty 
sheet of positive paper is an empty claim and is treated as a logical tautology (true).

When there is there is more than one RDF graph on the surface, then it is a logical conjunction (AND). 
If we interpret the sheets of paper with the black border in the examples above as
positive surfaces, then  they express:

- Example 1: true
- Example 2: It is true that:  Ghent a City.
- Example 3: It is true that: ∃ x : x  a City
- Example 4: It is true that: ∃ x , y : ( x a City ) AND ( y a Cat )

The [blank nodes](https://www.w3.org/TR/rdf11-mt/#blank-nodes) need to be interpreted
as logical existentials on logical paper.

**Negative surface**

In the same way as a *positive surface* asserts a logical truth, a **negative surface**
asserts a logical negation. The examples below will use a sheet of paper with a red border
as a negative surface.

An empty *negative surface* expresses a logical contradicton, false. When there are one
or more RDF graphs written on an *negative* surface they mean the negation of those RDF graphs.

A blank node on a negative surface is interpreted as a logical universal. The reason is 
that:

```
NOT(∃ x : P(x)) ⇔ ∀ x : NOT(P(x))
```

<div class=example>
An empty *negative surface* is a contradiction.

<img alt="blank surface" src="images/negative_surface.svg" width="300"/>
</div>

<div class=example>
A *negative surface* with one triple `:Ghent a :Cat` means *"It is not the case that Ghent is a cat"*.

<img alt="blank surface" src="images/city_not_cat.svg" width="300"/>
</div>

<div class=example>
A *negative surface* with one triple `[] a :City` means 
*"It is not the case that something is a city"* , or *"Nothing is a city"*.

<img alt="blank surface" src="images/nothing_a_city.svg" width="300"/>
</div>

**Propositional logic**

With combination of conjunction, by putting triples on a *positive surface*, 
and negation, by putting triples on a *negative surface*, any **compound 
truth-functional statement** can be symbolized with positive and negative sheets
of paper:

- The logical conjunction **AND** is given by putting RDF triples on a *positive surface*.
- The logical negation **NOT** is given by putting RDF triples on a *negative surface*.
- The logical disjunction **OR** can be made by a combination of *positive* and *negative surfaces*:
    - `NOT(P AND Q) = NOT(P) OR NOT(Q)`
    - `NOT( NOT(P) AND NOT(Q)) = P OR Q`
- The logical implication **→** can be made with a combination of **AND** and **OR**:
    - `P → Q = NOT(P) OR Q = NOT( P AND NOT(Q) )`

<div class=example>
Propositional logic using *positive* and *negative* surfaces.

<img alt="blank surface" src="images/propositional_logic.svg" width="500"/>
</div>

**First-order logic**

First-order logic can be added to the RDF surfaces by interpreting the blank node as 
an existential and using the rule that a universal can made from an existential by 
placing it in an enclosing negative surface: 

```
∀ x : P(x) ⇔ NOT(∃ x : NOT P(x)):
```

- By placing a blank node on a *positive surface* it is an existential.
- By placing a blank node on a *negative surface* it is an universal.

<div class=example>
First-order logic using *positive* and *negative* surfaces.

<img alt="blank surface" src="images/first_order_logic.svg" width="500"/>
</div>

**First-order logic in Notation3**

RDF Surfaces provides a way to express the notion of *positive* and *negative surfaces*
in Notation3 with help of the built-ins `log:onPositiveSurface` and `log:onNegativeSurface`.

The subject of both built-ins are the blank nodes that need to be put on the 
surface (so that they become existentials or universals depeding on the type
of surface). 

<div class=example>
*"Something is a city"* in Notation3 .

```
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

(_:X) log:onPositiveSurface {
    _:X a :City .
} .
```
</div>

<div class=example>
*"Something is a city"* in Notation3 , version 2 : because the default surface 
is defined as a positive surface.

```
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

_:X a :City .
```
</div>

<div class=example>
*"Nothing is a problem"* in Notation3 .

```
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

(_:X) log:onNegativeSurface {
    _:X a :Problem .
} .
```
</div>

<div class=example>
*"All cats are alive OR dead"* in Notation3. These are Schrödinger cats: logical OR can
mean alive, or dead, or both alive and dead. 

```
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

(_:X) log:onNegativeSurface {
    _:X a :Cat .

    () log:onNegativeSurface {
        _:X :is :Alive .
    } .

    () log:onNegativeSurface {
        _:X :is :Dead .
    } .
} .
```
</div>

<div class=example>
*"If any cat X is alive, then X says meow"* in Notation3 .

```
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

(_:X) log:onNegativeSurface {
    _:X a :Cat ;
        :is :Alive .
    () log:onNegativeSurface {
        _:X :says :Meow .
    } .
} .
```
</div>

A surface can be queried by providing a query surface. The results of this 
query will be the final result the reasoning engine interpreting the surfaces.

<div class=example>

`:Ghent a :City` is a triple on the implicit positive surface. The two nested
negative surfaces express that for any subject `_:S` on the positive service
that is a `:City`, it implies that `_:S` needs be be also a `:HumanCommunity`.

<pre highlight="turtle">
@prefix log: &lt;http://www.w3.org/2000/10/swap/log#&gt;.
@prefix ex: &lt;http://example.org/ns#&gt;.

ex:Ghent a ex:City.

# Every city is a human community
(_:S) log:onNegativeSurface {
    _:S a ex:City.
    () log:onNegativeSurface {
        _:S a ex:HumanCommunity.
    }.
}.

# Query
(_:S _:C) log:onQuerySurface {
    _:S a _:C.
}.
</pre>

When this surface is executed by a reasoner the result would be:

<pre highlight="turtle">
@prefix ex: &lt;http://example.org/ns#&gt;.

ex:Ghent a ex:City.
ex:Ghent a ex:HumanCommunity.
</pre>

</div>

More test cases can be found at [https://github.com/josd/know/blob/master/etc.md](https://github.com/josd/know/blob/master/etc.md) .

Document Conventions
=====================

Within this document, the following namespace prefix bindings to [[URI]]-s are used: 

<table>
  <thead>
    <tr>
      <th>Prefix
      <th>Namespace
  <tbody>
    <tr>
      <td>ex
      <td>http://example.org/ns#
    <tr>
      <td>rdf
      <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#
    <tr>
      <td>log
      <td>http://www.w3.org/2000/10/swap/log#
    <tr>
      <td>list
      <td>http://www.w3.org/2000/10/swap/list#
    <tr>
      <td>string
      <td>http://www.w3.org/2000/10/swap/string#
</table>

Surface {#Surface}
==============================

Surfaces are written as triples where the `subject` is a list of zero or more blank nodes. 
The `object` is a RDF graph or the `true` or `false` literal. The blank nodes in the 
subject list are treated as marks on the object RDF graph. The `predicate` specifies 
the kind of surface. Any kind of surface may be used but the following built-in have 
special semantics:

<table>
 <thead>
 <tr>
  <td>built-in
  <td>semantics
 </tr>
 </thead>
 <tbody>
 <tr>
  <td>`log:onPositiveSurface`
  <td>Positive surfaces claim that an RDF graph on them is true
 <tr>
  <td>`log:onNegativeSurface`
  <td>Negative surfaces claim that an RDF graph on them is false
 <tr>
  <td>`log:onNeutralSurface`
  <td>Neutral surfaces don't claim that the RDF graph on them is true or false
 <tr>
  <td>`log:onQuerySurface`
  <td>Query surfaces use the RDF graph on them as a query
 <tr>
  <td>`log:onAskSurface`
  <td>Ask surfaces use the RDF graph on them as a boolean query
 </tbody>
</table>

A surface can contain zero or more other surfaces. These surfaces are then nested.
Nested surfaces can share the same [[URI]]-s and literals (by copying the data), 
but can't share blank nodes. 

<div class=example>
A `ex:myFirstSurface` is created which contains two triples and a nested surface. The
blank node `_:X` is part of `ex:myFirstSurface`. On the nested surface 
`ex:mySecondSurface` the blank node `_:X` is the node from `ex:myFirstSurface`, the
blank node `_:Y` is created on `ex:mySecondSurface`.

```
@prefix ex: <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

(_:X) ex:myFirstSurface {

    ex:Statement1 a ex:NiceStatement .
    _:X a ex:OtherStatement .
     
    (_:Y) ex:mySecondSurface {
        _:X ex:is true . 
        _:Y a ex:AnotherStatement .
    }.
} .
```
</div>

## Positive Surface ## {#PositiveSurface}

A positive surface is an RDF graph which claims that an RDF Graph on it is true.
This is the current default interperation of [RDF Semantics](https://www.w3.org/TR/rdf11-mt/).
When no surfaces are provided, an implicit positive surface is assumed in the RDF document.

<div class=example>
The two surfaces below are equal.

```
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

() log:onPositiveSurface {
    :Alice a :Person .
}
```

and

```(turtle)
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

:Alice a :Person .
```
</div>

The semantics of a positive surface is interpreted as a logical truth:

- An empty positive surface is a tautology 
- When a triple is placed on a positive surface, then surface is valid when the triple is true.
- When two or more triples are placed on a positive surface, then the surface is valid when the logical conjunction of all triples is true.

<div class="example">
The surface below should be interpreted as: "Alice is a person and knows Bob, and Bob is a 
person that knows Alice". 

As a logical statement:

```
  :Alice a :Person AND 
  :Alice :knows :Bob AND (
    :Bob a :Person AND 
    :Bob :knows :Alice
```

As RDF Surface:

```(turtle)
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

:Alice a :Person .
:Alice :knows :Bob .

() log:onPositiveSurface {
    :Bob a :Person .
    :Bob :knows :Alice .
} .
```
</div>

When a blank node is marked on a positive surface, then it is interpreted as an existential 
variable in the scope of the positive surface.

<div class="example">
The surface below should be interpreted as : "Alice is a person and there is a person that
knows Alice".

As a logical statement:

```
  :Alice a :Person AND 
  :Alice :knows :Bob AND (
    ∃ _:X : _:X a :Person AND 
            _:X :knows :Alice
  )
```

As RDF Surface:

```(turtle)
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

:Alice a :Person .
:Alice :knows :Bob .

(_:X) log:onPositiveSurface {
    _:X a :Person .
    _:X :knows :Alice .
} .
```
</div>

## Negative Surface ## {#NegativeSurface}

A negative surface is an RDF graph which claims that an RDF Graph on it is false. The
intepretation of the negative surface is the negation of RDF Graph on it. 

The semantics of a negative surface is interpreted as a logical falsehood:

- An empty negative surface is a contradiction.
- When a triple is placed on a negative surface, then surface is valid when the triple is false.
- When two or more triples are placed on a positive surface, then the surface is valid when the logical conjunction of all triples is false.

<div class="example">
The surface below should be interpreted as: "Alice is a person and knows Bob and Bob is
not a person that knows Alice".

As a logical statement:

```
  :Alice a :Person AND 
  :Alice :knows :Bob AND NOT (
    :Bob a :Person AND 
    :Bob :knows :Alice
  )
```

As RDF Surface:

```(turtle)
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

:Alice a :Person .
:Alice :knows :Bob .

() log:onNegativeSurface {
    :Bob a :Person .
    :Bob :knows :Alice .
} .
```
</div>

When a blank node is marked on a negative surface, then it should be interpreted as an existential
variable in the scope of the negative surface. 

<div class="example">
The surface below should be interpreted as "Alice is a Person and knows Bob 
and there isn't a person that knows Alice".

As a logical statement:

```
  :Alice a :Person AND 
  :Alice :knows :Bob AND NOT (
    ∃ _:X :
       _:X a :Person AND 
       _:X :knows :Alice
  )
```

which is the same as:

```
  :Alice a :Person AND 
  :Alice :knows :Bob AND 
    ( ∀ _:X :
       NOT (
        _:X a :Person AND 
        _:X :knows :Alice
      )
    ) 
  )
```

As RDF Surface:

```(turtle)
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

:Alice a :Person .
:Alice :knows :Bob .

(_:X) log:onNegativeSurface {
    _:X a :Person .
    _:X :knows :Alice .
} .
```
</div>

When two or more negative surfaces are nested in a parent negative surface, then it should
be interpreted as a logical disjunction.

<div class="example">
The surface below should be interpreted as "Alice is a Person OR Bob is a Person
OR Charly is a person".

As a logical statement:

```
  :Alice a :Person OR
  :Bob a :Person OR
  :Charly a :Person 
```

which is the same as:

```
  NOT(
    NOT(:Alice a :Person) AND
    NOT(:Bob a :Person) AND
    NOT(:Charly a :Person)
  )
```

As RDF Surface:

```(turtle)
@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

:Alice a :Person .
:Alice :knows :Bob .

() log:onNegativeSurface {
    () log:onNegativeSurface {
      :Alice a :Person .
    } .

    () log:onNegativeSurface {
      :Bob a :Person .
    } .

    () log:onNegativeSurface {
      :Charly a :Person .
    } .
}.
```
</div>

With combinations of AND and NOT other logical truth function can be build. E.g.

- Disjunction: `P ∨ Q` : `NOT( NOT(P) AND NOT(Q))`
- Material implication `P → Q` : `NOT( P AND NOT Q )` .
- Converse implication `P ← Q` : `NOT( NOT(P) AND Q )` .
- Biconditional `(P → Q) ∧ (Q → P)` : `NOT( P AND NOT Q ) AND NOT( Q AND NOT P )`

Negative surfaces should also follow the law of double negation elimination: `P = NOT(NOT(P))`.

## Query Surface ## {#QuerySurface}

A negative surface containing a query surface is treated as a backward rule.

Issue: TODO

## Ask Surface ## {#AskSurface}

Issue: TODO

## Neutral Surface ## {#NeutralSurface}

Issue: TODO

## Other Surfaces ## {#OtherSurface}

Issue: TODO

## Blank nodes ## {#BlankNodes}

Issue: TODO

Coherent logic {#CoherentLogic}
================

Issue: TODO

Examples {#Examples}
================

Issue: TODO

<pre class=biblio>
{
	"N3": {
		"authors": [
			"Dörthe Arndt",
			"William Van Woensel",
			"Dominik Tomaszuk" ,
            "Gregg Kellogg"
		],
		"href": "https://w3c.github.io/N3/spec/",
		"title": "Notation3",
		"status": "Draft Community Group Report"
	}
}
</pre>
